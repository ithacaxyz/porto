import { http, createClient } from 'viem'
import { getCapabilities } from 'viem/actions'
import { readFile, writeFile } from 'node:fs/promises'
import * as Chains from 'viem/chains'

// TODO: Update wagmi.config.ts
console.log('Fetching chains for environments.')

const environments = [
  {
    name: 'prod',
    rpc: 'https://rpc.porto.sh',
    transportOverrides: {
      arbitrum: 'import.meta.env.VITE_RPC_URL_ARBITRUM',
      base: 'import.meta.env.VITE_RPC_URL_BASE',
      bsc: 'import.meta.env.VITE_RPC_URL_BSC',
      optimism: 'import.meta.env.VITE_RPC_URL_OPTIMISM',
      polygon: 'import.meta.env.VITE_RPC_URL_POLYGON',
    },
  },
  { name: 'stg', rpc: 'https://stg-rpc.porto.sh', transportOverrides: {} },
] as const satisfies readonly {
  name: 'prod' | 'stg'
  rpc: string
  transportOverrides: Partial<Record<keyof typeof Chains, string>>
}[]

const configPath = './apps/~internal/lib/PortoConfig.ts'
const chainsSet = new Set<string>([])
for (const environment of environments) {
  console.log(`\n${environment.name} â€” ${environment.rpc}`)

  const client = createClient({
    transport: http(environment.rpc),
  })

  const capabilities = await getCapabilities(client)
  const supportedChainIds = Object.keys(capabilities).map(Number)

  const allChains = Object.entries(Chains)
  let supportedChains: string[] = []
  for (const chainId of supportedChainIds) {
    const entry = allChains.find(([, chain]) => chain.id === chainId)
    if (!entry) {
      console.warn(`No chain found for id ${chainId}. Please add it to Viem.`)
      continue
    }
    const slug = entry[0]
    supportedChains.push(slug)
    chainsSet.add(slug)
  }
  supportedChains = supportedChains.toSorted()

  console.log(
    `Found ${supportedChains.length} chains\n${supportedChains.map((v, i) => `${i + 1}. ${v}`).join('\n')}`,
  )

  console.log(`Updating ${configPath}`)
  const file = await readFile(configPath, 'utf8')
  let content = replaceChainsByEnvironment(
    file,
    environment.name,
    supportedChains,
  )
  content = replaceTransportsByEnvironment(
    content,
    environment.name,
    supportedChains,
    environment.transportOverrides,
  )
  await writeFile(configPath, content)

  if (environment.name === 'prod') {
    const chainsPath = './src/core/internal/_generated/chains.ts'
    console.log(`Updating ${chainsPath}`)
    const content = exportChains(supportedChains)
    await writeFile(chainsPath, content)

    const docsPath = './apps/docs/pages/sdk/api/chains.mdx'
    console.log(`Updating ${docsPath}`)
    const docsFile = await readFile(docsPath, 'utf8')
    const docsContent = replaceChainsSupportedTable(docsFile, supportedChains)
    await writeFile(docsPath, docsContent)
  }
}

console.log(`\nUpdating imports ${configPath}`)
const file = await readFile(configPath, 'utf8')
const content = replaceChainsForViemChainsImport(
  file,
  [...chainsSet.values()].toSorted(),
)
await writeFile(configPath, content)

console.log('\nDone.')

////////////////////////////////////////////////////////////////////////////////////

function replaceChainsByEnvironment(
  content: string,
  environment: 'prod' | 'stg',
  newChains: string[],
) {
  const pattern = new RegExp(
    `(\\b${environment}\\s*:\\s*\\{[^}]*?chains:\\s*\\[)[\\s\\S]*?(\\][^}]*?\\})`,
    'g',
  )

  return content.replace(pattern, (_match, start, end) => {
    const baseIndent = '    '
    const chainIndent = '      '
    const chainsList = newChains
      .map((chain) => `${chainIndent}${chain},`)
      .join('\n')
    return `${start}\n${chainsList}\n${baseIndent}${end}`
  })
}

function replaceTransportsByEnvironment(
  content: string,
  environment: 'prod' | 'stg',
  newChains: string[],
  transportOverrides: Record<string, string>,
): string {
  const pattern = new RegExp(
    `(${environment}:\\s*\\{[\\s\\S]*?transports:\\s*\\{)[\\s\\S]*?(\\}[\\s\\S]*?\\})`,
    'g',
  )

  return content.replace(pattern, (_match, start, end) => {
    const baseIndent = '      '
    const transportsList = newChains
      .map((chain) => {
        const chainId = `${chain}.id`
        const rpcUrl = transportOverrides[chain]
        const transport = rpcUrl
          ? rpcUrl.startsWith('http')
            ? `http('${rpcUrl}')`
            : `http(${rpcUrl})`
          : 'http()'
        return `${baseIndent}[${chainId}]: ${transport},`
      })
      .join('\n')
    return `${start}\n${transportsList}\n    ${end}`
  })
}

function replaceChainsForViemChainsImport(
  content: string,
  newChains: string[],
) {
  const pattern = /import\s*\{[^}]*\}\s*from\s+['"]viem\/chains['"]/g

  return content.replace(pattern, () => {
    const indent = '  '
    const chainsList = newChains.map((chain) => `${indent}${chain}`).join(',\n')
    return `import {\n${chainsList},\n} from 'viem/chains'`
  })
}

function exportChains(chains: string[]) {
  return [
    '// Generated by `pnpm gen:chains`',
    'export {',
    ...chains.map((chain) => `  ${chain},`),
    `} from 'viem/chains'`,
  ].join('\n')
}

function replaceChainsSupportedTable(content: string, newChains: string[]) {
  const pattern =
    /(\|\s*Chain\s*\|\s*Value\s*\|\s*\n\|\s*-+\s*\|\s*-+\s*\|\s*\n)([\s\S]*?)(?=\n\n|\n(?=##))/

  return content.replace(pattern, (_match, tableHeader) => {
    const rows = newChains
      .map((chain) => {
        // biome-ignore lint/performance/noDynamicNamespaceImportAccess: _
        const displayName = Chains[chain as keyof typeof Chains].name
        return `| ${displayName} | \`Chains.${chain}\` |`
      })
      .join('\n')

    return `${tableHeader}${rows}`
  })
}

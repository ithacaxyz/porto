import { Example } from '../../../components/guides/Siwe'
import { GuideDemoContainer } from '../../../components/GuideDemoContainer'

# Authentication (SIWE)

## Example

<GuideDemoContainer>
  <Example />
</GuideDemoContainer>

## Steps

::::steps

### Connect Account

Follow the [Onboard & Discover Accounts](/sdk/guides/discover-accounts) guide to get this set up.

### Setup API

Sign in with Ethereum [requires a nonce](https://eips.ethereum.org/EIPS/eip-4361#message-fields) to be generated by the server to prevent replay attacks. You will need to set up a API endpoint to return a nonce. For example, using [Hono](https://hono.dev) and [Ox](https://oxlib.sh).

:::note
For production, this step is required, but if you are just experimenting, you can skip this step and call `Siwe.generateNonce` or similar directly in the next step.
:::

```ts
import { Hono } from 'hono'
import { Siwe } from 'ox'

const app = new Hono()

app.get('/api/nonce', (c) => c.text(Siwe.generateNonce()))

export default app
```

### Add `signInWithEthereum` capability to `connect`

We will reuse the same components from the
[Onboard & Discover Accounts](/sdk/guides/discover-accounts#https://dev.porto.sh/sdk/guides/discover-accounts#display-sign-in-button)
guide with one change: we will add the `signInWithEthereum` capability during connect along with fetching the nonce from the previous step.

:::note
Wagmi does not return `capabilities` as part of `useConnect.connect` at the moment so falling back to Porto `provider.request` for now.
:::

```tsx
import type { Porto } from 'porto'
import { useChainId, useConnect } from 'wagmi'

export function Connect() {
  const chainId = useChainId()
  const { connectors } = useConnect()

  const connector = connectors.find(
    (connector) => connector.id === 'xyz.ithaca.porto',
  )!

  return (
    <button
      onClick={async () =>
        const provider = (await connector.getProvider({ chainId })) as Porto.Porto['provider']
        const result = await provider.request({
          method: 'wallet_connect',
          params: [
            {
              capabilities: {  // [!code ++]
                signInWithEthereum: {  // [!code ++]
                  chainId,  // [!code ++]
                  nonce: await fetch("/api/nonce").then(res => res.text()),  // [!code ++]
                },  // [!code ++]
              },  // [!code ++]
            },
          ],
        })
      }
      type="button"
    >
      Sign in
    </button>
  )
}
```

### Verify signature

Now that we are connected, the last step is to verify the Sign in with Ethereum signature. If the signature is valid, you could create a new session, issue a JWT, or more.

:::note
Using `provider` until there is a `useVerifySignature` hook added to `'porto/wagmi'`
:::

```tsx
import type { Porto } from 'porto'
import { useChainId, useConnect } from 'wagmi'

export function Connect() {
  const chainId = useChainId()
  const { connectors } = useConnect()

  const connector = connectors.find(
    (connector) => connector.id === 'xyz.ithaca.porto',
  )!

  return (
    <button
      onClick={async () =>
        const provider = (await connector.getProvider({ chainId })) as Porto.Porto['provider']
        const result = await provider.request({
          method: 'wallet_connect',
          params: [ /* ... */ ],
        })
        const siwe = res.accounts.at(0)?.capabilities?.signInWithEthereum! // [!code ++]
        const { valid } = await provider.request({ // [!code ++]
          method: 'wallet_verifySignature', // [!code ++]
          params: [ // [!code ++]
            { // [!code ++]
              address: res.accounts.at(0)?.address!, // [!code ++]
              digest: hashMessage(siwe.message), // [!code ++]
              signature: siwe.signature, // [!code ++]
            }, // [!code ++]
          ], // [!code ++]
        }) // [!code ++]
      }
      type="button"
    >
      Sign in
    </button>
  )
}
```

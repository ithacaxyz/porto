#!/usr/bin/env bun

import { watch } from 'node:fs'
import { parseArgs } from 'node:util'
import type { PortoTheme } from './porto-theme.js'

const GENERATED_BY = 'theme generated by apps/theme/export-theme.ts'

type Entries<T> = { [K in keyof T]: [K, T[K]] }[keyof T][]

let args: ReturnType<typeof parseArgs>
try {
  args = parseArgs({
    allowPositionals: true,
    args: Bun.argv,
    options: {
      as: {
        default: 'css',
        type: 'string',
      },
      help: {
        default: false,
        short: 'h',
        type: 'boolean',
      },
      'no-confirm': {
        default: false,
        type: 'boolean',
      },
      out: {
        default: '',
        short: 'o',
        type: 'string',
      },
      watch: {
        default: false,
        short: 'w',
        type: 'boolean',
      },
    },
    strict: true,
  })
} catch (error) {
  console.error('\nError parsing arguments:\n')
  throw error
}

function cssVars(theme: PortoTheme, prefix = '--') {
  const vars: Record<string, { description?: string; value?: string }> = {}
  for (const [key, value] of Object.entries(theme) as Entries<PortoTheme>) {
    if (key === 'colorScheme' || value === null) continue

    const varName = `${prefix}${camelCaseToKebabCase(key)}`

    if (Array.isArray(value) && value.length === 3) {
      vars[varName] = {
        description: value[0],
        value: `light-dark(${cssValue(value[1])}, ${cssValue(value[2])})`,
      }
    }
  }
  return vars
}

function tailwindCssVars(theme: PortoTheme, prefix = '--') {
  const vars: Record<string, { description?: string; value?: string }> = {}
  for (const [key, value] of Object.entries(theme) as Entries<PortoTheme>) {
    if (key === 'colorScheme' || value === null) continue

    const varName = formatTailwindVarName(key, prefix)

    if (Array.isArray(value) && value.length === 3) {
      vars[varName] = {
        description: value[0],
        value: `light-dark(${cssValue(value[1])}, ${cssValue(value[2])})`,
      }
    }
  }
  return vars
}

function cssValue(value: string | number): string {
  if (typeof value === 'string' && value.startsWith('#'))
    return value.toLowerCase()
  return typeof value === 'number' ? `${value}px` : value
}

function camelCaseToKebabCase(str: string): string {
  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()
}

const PART_NAMES = ['background', 'content', 'border'] as const
const VARIANT_NAMES = ['error'] as const
const STATE_NAMES = ['hovered', 'focused', 'pressed'] as const

function parseColorName(colorName: string): {
  surface: string
  variant?: string
  state?: string
  part: 'background' | 'content' | 'border' | 'other'
  partVariant?: string
} {
  const parts: string[] = []
  let current = ''

  for (const [index, char] of colorName.split('').entries()) {
    const isUpperCase = char === char.toUpperCase()

    if (index === 0 || !isUpperCase) {
      current += char
      continue
    }

    parts.push(current.toLowerCase())
    current = char
  }
  if (current) parts.push(current.toLowerCase())

  let part: 'background' | 'content' | 'border' | 'other' = 'other'
  let partIndex = -1

  for (const partName of PART_NAMES) {
    if (parts.includes(partName)) {
      part = partName
      partIndex = parts.indexOf(partName)
      break
    }
  }

  if (part === 'other') {
    return {
      part: 'other',
      surface: colorName.toLowerCase(),
    }
  }

  const beforePart = parts.slice(0, partIndex)
  const surface = beforePart[0] || ''

  const state = parts.find((p) =>
    STATE_NAMES.includes(p as (typeof STATE_NAMES)[number]),
  )
  const variant = parts.find((p) =>
    VARIANT_NAMES.includes(p as (typeof VARIANT_NAMES)[number]),
  )

  return { part, state, surface, variant }
}

function formatTailwindVarName(colorName: string, prefix: string): string {
  const parsed = parseColorName(colorName)

  let varName = prefix

  if (parsed.part === 'background') {
    varName += 'background-color-th_'
  } else if (parsed.part === 'content') {
    varName += 'text-color-th_'
  } else if (parsed.part === 'border') {
    varName += 'border-color-th_'
  } else if (parsed.part === 'other') {
    varName += 'color-th_'
  }

  const parts = [parsed.surface]
  if (parsed.variant) parts.push(parsed.variant.toLowerCase())
  if (parsed.state) parts.push(parsed.state.toLowerCase())

  varName += parts.join('-')

  return varName
}

function css(
  theme: PortoTheme,
  {
    comments,
    nestIn,
    prefix = '',
  }: {
    comments?: boolean
    nestIn?: string
    prefix?: string
  } = {},
) {
  const padding = nestIn ? '  ' : ''

  let cssContent = `/* ${GENERATED_BY} */\n`

  if (nestIn) cssContent += `\n${nestIn} {\n`
  cssContent += Object.entries(cssVars(theme, prefix))
    .map(([key, { value, description }]) => {
      return (
        (comments && description ? `${padding}/* ${description} */\n` : '') +
        `${padding}${key}: ${value};`
      )
    })
    .join(comments ? '\n\n' : '\n')

  if (nestIn) cssContent += '\n}'

  return cssContent
}

function tailwindCss(
  theme: PortoTheme,
  {
    comments,
  }: {
    comments?: boolean
  } = {},
) {
  const padding = '  '

  let cssContent = `/* ${GENERATED_BY} */\n\n@theme {\n`

  const vars = tailwindCssVars(theme, '--')
  cssContent += Object.entries(vars)
    .map(([key, { value, description }]) => {
      return (
        (comments && description ? `${padding}/* ${description} */\n` : '') +
        `${padding}${key}: ${value};`
      )
    })
    .join(comments ? '\n\n' : '\n')

  cssContent += '\n}'

  return cssContent
}

const formatExporters = {
  css(theme) {
    return css(theme, {
      comments: false,
      nestIn: ':root',
      prefix: '--color-',
    })
  },
  css_commented(theme) {
    return css(theme, {
      comments: true,
      nestIn: ':root',
      prefix: '--color-',
    })
  },
  json(theme) {
    const themeOnly = Object.fromEntries(
      Object.entries(theme).map(([key, value]) => {
        if (key === 'colorScheme') return [key, value]
        if (Array.isArray(value) && value.length === 3) {
          return [key, [value[1], value[2]]]
        }
        return [key, value]
      }),
    )
    return JSON.stringify(themeOnly, null, 2)
  },
  tailwind(theme) {
    return tailwindCss(theme, { comments: false })
  },
  tailwind_commented(theme) {
    return tailwindCss(theme, { comments: true })
  },
} satisfies Record<string, (theme: PortoTheme) => string>

if (args.values.help) {
  console.log(`
Usage: export-theme.ts [options]

Options:
  --as <format>      Output format (default: css).
                     Supported formats: ${Object.keys(formatExporters).join(', ')}.
  --help, -h         Show this help message.
  --out              File to write the exported theme to. Prints to stdout if not specified.
  --watch, -w        Watch for changes and re-export the theme. Requires an output file.
`)
  process.exit(0)
}

const isValidExporter = (as: unknown): as is keyof typeof formatExporters => {
  return typeof as === 'string' && Object.keys(formatExporters).includes(as)
}

if (!isValidExporter(args.values.as)) {
  console.error(
    `Invalid format: ${args.values.as}. Supported formats: ${Object.keys(formatExporters).join(', ')}.`,
  )
  process.exit(1)
}

const outPath =
  (typeof args.values.out === 'string' && args.values.out.trim()) || null

async function exportTheme(confirmIfExists = true) {
  if (!isValidExporter(args.values.as)) throw new Error() // type guard

  delete require.cache[require.resolve('./porto-theme.js')]
  const { portoTheme } = await import('./porto-theme.js')

  const exporter = formatExporters[args.values.as]
  const output = exporter(portoTheme)

  if (outPath) {
    const file = Bun.file(outPath)
    if (await file.exists()) {
      const shouldOverwrite =
        confirmIfExists && !args.values['no-confirm']
          ? confirm(`File ${outPath} already exists. Overwrite?`)
          : true
      if (!shouldOverwrite) {
        console.error('Export cancelled.')
        return
      }
    }

    await Bun.write(outPath, output)
    console.log(`Theme exported to ${outPath} in ${args.values.as} format.`)
  } else {
    console.log(output)
  }
}

if (args.values.watch) {
  const stdoutMode = outPath === null
  if (stdoutMode) console.clear()

  exportTheme()

  if (!stdoutMode) console.log('Watching for changes…')

  watch('./porto-theme.ts', async (eventType, filename) => {
    if (eventType === 'change') {
      if (stdoutMode) console.clear()
      else console.log(`\n${filename} changed, re-exporting…`)
      try {
        await exportTheme(false)
      } catch (error) {
        console.error('Error re-exporting theme:', error)
      }
    }
  })
} else {
  exportTheme()
}

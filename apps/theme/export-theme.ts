#!/usr/bin/env bun

import { parseArgs } from 'node:util'
import { portoTheme } from './porto-theme.js'
import { isCombinedColor } from './Theme.js'

const GENERATED_BY = 'theme generated by apps/theme/export-theme.ts'

export type Entries<T> = { [K in keyof T]: [K, T[K]] }[keyof T][]

let args: ReturnType<typeof parseArgs>
try {
  args = parseArgs({
    allowPositionals: true,
    args: Bun.argv,
    options: {
      as: {
        default: 'css_in_json',
        type: 'string',
      },
    },
    strict: true,
  })
} catch (error) {
  console.error('\nError parsing arguments:\n')
  throw error
}

function cssVars(theme: typeof portoTheme, prefix = '--') {
  const vars: Record<string, { description?: string; value?: string }> = {}
  for (const [key, value] of Object.entries(theme) as Entries<
    typeof portoTheme
  >) {
    if (key === 'colorScheme' || value === null) continue

    const themeKey = key.endsWith('Description')
      ? key.slice(0, -'Description'.length)
      : key

    const varName = `${prefix}${camelCaseToKebabCase(themeKey)}`
    if (!vars[varName]) vars[varName] = {}

    if (key.endsWith('Description')) {
      vars[varName].description = value as string
      continue
    }

    vars[varName].value = isCombinedColor(value)
      ? `light-dark(${pxValue(value[0])}, ${pxValue(value[1])})`
      : pxValue(value)
  }
  return vars
}

function pxValue(value: string | number): string {
  return typeof value === 'number' ? `${value}px` : value
}

function camelCaseToKebabCase(str: string): string {
  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()
}

function css(
  theme: typeof portoTheme,
  {
    comments,
    nestIn,
    prefix = '',
  }: {
    comments?: boolean
    nestIn?: string
    prefix?: string
  } = {},
) {
  const padding = nestIn ? '  ' : ''

  let cssContent = `/* ${GENERATED_BY} */\n`

  if (nestIn) cssContent += `\n${nestIn} {\n`
  cssContent += Object.entries(cssVars(theme, prefix))
    .map(([key, { value, description }]) => {
      return (
        (comments && description ? `${padding}/* ${description} */\n` : '') +
        `${padding}${key}: ${value};`
      )
    })
    .join(comments ? '\n\n' : '\n')

  if (nestIn) cssContent += `\n}`

  return cssContent
}

const formatExporters = {
  css(theme) {
    return css(theme, {
      comments: false,
      nestIn: ':root',
      prefix: '--color-',
    })
  },
  css_commented(theme) {
    return css(theme, {
      comments: true,
      nestIn: ':root',
      prefix: '--color-',
    })
  },
  json(theme) {
    const themeOnly = Object.fromEntries(
      Object.entries(theme).filter(([key]) => !key.endsWith('Description')),
    )
    return JSON.stringify(themeOnly, null, 2)
  },
  tailwind(theme) {
    return css(theme, {
      comments: false,
      nestIn: '@theme',
      prefix: '--color-th_',
    })
  },
  tailwind_commented(theme) {
    return css(theme, {
      comments: true,
      nestIn: '@theme',
      prefix: '--color-th_',
    })
  },
} satisfies Record<string, (theme: typeof portoTheme) => string>

const isValidExporter = (as: unknown): as is keyof typeof formatExporters => {
  return typeof as === 'string' && Object.keys(formatExporters).includes(as)
}

if (!isValidExporter(args.values.as)) {
  console.error(
    `Invalid format: ${args.values.as}. Supported formats: ${Object.keys(formatExporters).join(', ')}.`,
  )
  process.exit(1)
}

const exporter = formatExporters[args.values.as]
const output = exporter(portoTheme)
console.log(output)

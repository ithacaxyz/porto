#!/usr/bin/env bun

import { watch } from 'node:fs'
import { parseArgs } from 'node:util'
import { portoTheme } from './porto-theme.js'
import { isCombinedColor } from './Theme.js'

const GENERATED_BY = 'theme generated by apps/theme/export-theme.ts'

type Entries<T> = { [K in keyof T]: [K, T[K]] }[keyof T][]

type PortoTheme = typeof portoTheme

let args: ReturnType<typeof parseArgs>
try {
  args = parseArgs({
    allowPositionals: true,
    args: Bun.argv,
    options: {
      as: {
        default: 'css',
        type: 'string',
      },
      help: {
        type: 'boolean',
        short: 'h',
        default: false,
      },
      watch: {
        type: 'boolean',
        default: false,
        short: 'w',
      },
      out: {
        type: 'string',
        short: 'o',
        default: '',
      },
      ['no-confirm']: {
        type: 'boolean',
        default: false,
      },
    },
    strict: true,
  })
} catch (error) {
  console.error('\nError parsing arguments:\n')
  throw error
}

function cssVars(theme: PortoTheme, prefix = '--') {
  const vars: Record<string, { description?: string; value?: string }> = {}
  for (const [key, value] of Object.entries(theme) as Entries<PortoTheme>) {
    if (key === 'colorScheme' || value === null) continue

    const themeKey = key.endsWith('Description')
      ? key.slice(0, -'Description'.length)
      : key

    const varName = `${prefix}${camelCaseToKebabCase(themeKey)}`
    if (!vars[varName]) vars[varName] = {}

    if (key.endsWith('Description')) {
      vars[varName].description = value as string
      continue
    }

    vars[varName].value = isCombinedColor(value)
      ? `light-dark(${pxValue(value[0])}, ${pxValue(value[1])})`
      : pxValue(value)
  }
  return vars
}

function pxValue(value: string | number): string {
  return typeof value === 'number' ? `${value}px` : value
}

function camelCaseToKebabCase(str: string): string {
  return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase()
}

function css(
  theme: PortoTheme,
  {
    comments,
    nestIn,
    prefix = '',
  }: {
    comments?: boolean
    nestIn?: string
    prefix?: string
  } = {},
) {
  const padding = nestIn ? '  ' : ''

  let cssContent = `/* ${GENERATED_BY} */\n`

  if (nestIn) cssContent += `\n${nestIn} {\n`
  cssContent += Object.entries(cssVars(theme, prefix))
    .map(([key, { value, description }]) => {
      return (
        (comments && description ? `${padding}/* ${description} */\n` : '') +
        `${padding}${key}: ${value};`
      )
    })
    .join(comments ? '\n\n' : '\n')

  if (nestIn) cssContent += '\n}'

  return cssContent
}

const formatExporters = {
  css(theme) {
    return css(theme, {
      comments: false,
      nestIn: ':root',
      prefix: '--color-',
    })
  },
  css_commented(theme) {
    return css(theme, {
      comments: true,
      nestIn: ':root',
      prefix: '--color-',
    })
  },
  json(theme) {
    const themeOnly = Object.fromEntries(
      Object.entries(theme).filter(([key]) => !key.endsWith('Description')),
    )
    return JSON.stringify(themeOnly, null, 2)
  },
  tailwind(theme) {
    return css(theme, {
      comments: false,
      nestIn: '@theme',
      prefix: '--color-th_',
    })
  },
  tailwind_commented(theme) {
    return css(theme, {
      comments: true,
      nestIn: '@theme',
      prefix: '--color-th_',
    })
  },
} satisfies Record<string, (theme: PortoTheme) => string>

if (args.values.help) {
  console.log(`
Usage: export-theme.ts [options]

Options:
  --as <format>      Output format (default: css).
                     Supported formats: ${Object.keys(formatExporters).join(', ')}.
  --help, -h         Show this help message.
  --out              File to write the exported theme to. Prints to stdout if not specified.
  --watch, -w        Watch for changes and re-export the theme. Requires an output file.
`)
  process.exit(0)
}

const isValidExporter = (as: unknown): as is keyof typeof formatExporters => {
  return typeof as === 'string' && Object.keys(formatExporters).includes(as)
}

if (!isValidExporter(args.values.as)) {
  console.error(
    `Invalid format: ${args.values.as}. Supported formats: ${Object.keys(formatExporters).join(', ')}.`,
  )
  process.exit(1)
}

const outPath =
  (typeof args.values.out === 'string' && args.values.out.trim()) || null

async function exportTheme(confirmIfExists = true) {
  if (!isValidExporter(args.values.as)) throw new Error() // type guard

  delete require.cache[require.resolve('./porto-theme.js')]
  const { portoTheme } = await import('./porto-theme.js')

  const exporter = formatExporters[args.values.as]
  const output = exporter(portoTheme)

  if (outPath) {
    const file = Bun.file(outPath)
    if (await file.exists()) {
      const shouldOverwrite =
        confirmIfExists && !args.values['no-confirm']
          ? confirm(`File ${outPath} already exists. Overwrite?`)
          : true
      if (!shouldOverwrite) {
        console.error('Export cancelled.')
        return
      }
    }

    await Bun.write(outPath, output)
    console.log(`Theme exported to ${outPath} in ${args.values.as} format.`)
  } else {
    console.log(output)
  }
}

if (args.values.watch) {
  const stdoutMode = outPath === null
  if (stdoutMode) console.clear()

  exportTheme()

  if (!stdoutMode) console.error('Watching for changes…')

  watch('./porto-theme.ts', async (eventType, filename) => {
    if (eventType === 'change') {
      if (stdoutMode) console.clear()
      else console.error(`\n${filename} changed, re-exporting…`)
      try {
        await exportTheme(false)
      } catch (error) {
        console.error('Error re-exporting theme:', error)
      }
    }
  })
} else {
  exportTheme()
}
